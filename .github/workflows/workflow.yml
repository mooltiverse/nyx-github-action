# This workflow takes care of building, testing and publishing the project and
# its artifacts.
#
# The whole process is split into jobs, each running on a different node.
# Jobs are executed conditionally, only when required, in order to avoid wasting
# build time on useless jobs.
# Job dependencies also make longer and expensive tasks depend on the success
# of previous, less expensive tasks. If upstream tasks fail, their dependencies
# are not executed.
#
# This implies that, in order to avoid repeating tasks and start one job from
# where previous ones have finished, intermediate artifacts are handed over
# from one task to another. For this we use cache actions like actions/cache@v4.
# Moreover, since we use Gradle and its powerful up-to-date checks, we also need
# to propagate the Gradle cache across jobs. For this we use the Gradle remote
# cache action burrunan/gradle-cache-action@v2.
#
# This way of modelling the workflow requires extra engineering but allows for
# fine grained control over the pipeline as a whole. It also introduces some
# overhead, but that comes with the benefit of controlling the workflow stage
# by stage.
#
# Gradle is used so that we use the same build scripts locally on developers'
# hosts and the CI/CD environment. Again, this improves portability and
# consistency.

name: Workflow
on: [push]
# Avoid running multiple pipelines concurrently to avoid overlapping releases and tags
concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: false

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    outputs:
      branch: ${{ steps.nyx.outputs.branch }}
      bump: ${{ steps.nyx.outputs.bump }}
      coreVersion: ${{ steps.nyx.outputs.coreVersion }}
      latestVersion: ${{ steps.nyx.outputs.latestVersion }}
      newRelease: ${{ steps.nyx.outputs.newRelease }}
      newVersion: ${{ steps.nyx.outputs.newVersion }}
      scheme: ${{ steps.nyx.outputs.scheme }}
      timestamp: ${{ steps.nyx.outputs.timestamp }}
      previousVersion: ${{ steps.nyx.outputs.previousVersion }}
      primeVersion: ${{ steps.nyx.outputs.primeVersion }}
      version: ${{ steps.nyx.outputs.version }}
    steps:
    - name: Git checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
    # Run a quick test (although it's shallow)
    - name: Test the Action
      id: nyx
      # Run the action directly from the checked out repository to make sure we're testing the one that has been pushed
      uses: ./
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        command: 'infer'
        verbosity: 'DEBUG'
        preset: 'extended'
        releaseLenient: 'true'
        stateFile: '.nyx-state.json'
        summaryFile: '.nyx-summary.txt'
    - name: Print version # This step uses the version inferred by Nyx
      run: echo the inferred version is ${{ steps.nyx.outputs.version }}

  publish:
    name: Publish
    runs-on: ubuntu-latest
    needs: test
    steps:
    - name: Git checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0
    - name: Publish the Action with Nyx
      id: nyx
      # Run the action directly from the checked out repository to make sure we're testing the one that has been pushed
      uses: ./
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        command: 'publish'
